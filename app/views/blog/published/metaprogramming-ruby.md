---
title: 'Metaprogramming Ruby'
created_at: '2014-06-03'
author: 'ابوالفضل محمودی'
---

Metaprogramming: تکنیکی است که در آن یک برنامه یا کد، براساس داده های ورودی و در زمان اجرا کد دیگری را تولید می کند.
در اینجا می خواهم با استفاده از Ruby بخشی از این تکنیک را پیاده سازی کنم. برای اینکار از دو متد `class_eval` و `instance_eval` استفاده می کنم. این متدها به شما امکان می دهد کد دلخواه خود را در قالب یک کلاس یا یک نمونه ایجاد شده از کلاس (object) تولید کنید. در مثال های زیر این روش را نشان می دهم:
<!--more-->

```ruby

class Person; end

Person.class_eval do
  def say_hello
    "Hello!"
  end	
end

joe = Person.new
joe.say_hello # "Hello!"

```

در مثال بالا class_eval به ما اجازه می دهد که به کلاس Person یک متد اضافه کنیم بدون اینکه به کد اصلی کلاس دست زده و تغییری در آن ایجاد کنیم. این ویژگی زمنی مفیده که شما به این کلاس تا زمان اجرا دسترسی ندارید یا مثلا بخواهید نام متد را براساس داده های موجود در پایگاه داده نام گذاری کنید.

```ruby

class Person; end

Person.instance_eval do
  def human?
    true
  end
end

Person.human? # true

```
در این مثال instance_eval  شبیه به class_eval است ولی به جای تولید یک متد از نوع نمونه کلاس، متدی از نوع استاتیک ایجاد می‌کند که با استفاده از نام کلاس و بدون ایجاد نمونه کلاس قابل فراخوانی است. این موضوع کمی گیج‌کننده است اما باید گفت که این دو متد کاملاً برعکس نامشان عمل می کنند. به این صورت که در instance_eval متد استاتیک تولید می شود اما class_eval متدی که باید با نمونه ایجاد شده کلاس آنرا فراخوانی نمود تولید می کند. به احتمال زیاد دلیلی برای این موضوع وجود دارد. (اشتباهی که خود من در یکی از آزمون ها مرتکب شدم)
فهم این موضوع ممکن است کمی سخت باشد به‌خصوص اگر قبلاً با Ruby برنامه نویسی نکرده باشید. اما این دو متد را باید برعکس یاد بگیرید. یعنی MyClass.class_eval متدی از نوع نمونه کلاس ایجاد میکند و MyClass.instance_eval متدی از نوع استاتیک ایجاد میکند.
